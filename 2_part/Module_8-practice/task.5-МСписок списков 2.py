print('\nЗадача v. .\n')

# РЕШЕНИЕ
# Вы уже работали с многомерными списками и решали задачи, где с помощью list comprehensions «выпрямляли» многомерные списки в один. Это не получится, если списков неограниченное количество и у элементов разные уровни вложенности.
#
# Дан такой список:
#
# nice_list = [1, 2, [3, 4], [[5, 6, 7], [8, 9, 10]], [[11, 12, 13], [14, 15], [16, 17, 18]]]
#
# Напишите рекурсивную функцию, которая раскрывает все вложенные списки, то есть оставляет только внешний список.
#
# Ответ: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
#
# Функция должна получать список и возвращать его раскрытую версию (не нужно добавлять элементы в список, записанный в глобальную переменную, созданную снаружи функции).
# =============================





# region {===== Основной код =====}

# функция для извлечения элемента из списка
def sub_list(name, summ_dict, full_name):
	if isinstance(name, list):
		# Функция которая идет по под-элементам списка и проверяет являются ли они списком или нет , если да то
		# возвращает эту функцию, если нет,то добовляет элемент в итоговый список и удаляет из изначального после
		# чего перезапускает функцию, пока изначальны элемент не будет равен пустому списку
		for letter in name:
			if letter != []:
				if isinstance(letter, list):
					return sub_list(letter, summ_dict, name)
				else:
					summ_dict.append(letter)
					name.remove(letter)
					return sub_list(full_name, summ_dict, full_name)
	else:
		return summ_dict
# функция для проверки под-элементов на наличие списков
def listt(name, summ_dict = [], full_name = []):
	for letter in name:
		if isinstance(letter, list):
			summ_dict.append(sub_list(letter, summ_dict, letter))
		else:
			summ_dict.append(letter)
	return summ_dict
lst = []
for letter in listt([1, 2, [3, 4], [[5, 6, 7], [8, 9, 10]], [[11, 12, 13], [14, 15], [16, 17, 18]]]):
	if letter != None:
		lst.append(letter)
print(lst)

# endregion {===== Основной код =====}